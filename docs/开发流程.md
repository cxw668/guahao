### 技术栈总览

| 层级     | 技术选型        | 版本建议               |
| -------- | --------------- | ---------------------- |
| 后端框架 | RuoYi-Vue3      | Spring Boot 3.x + Vue3 |
| 管理端   | RuoYi-Vue3 自带 | Element Plus           |
| 医生端   | Pure Admin      | Vue3 + Element Plus    |
| 患者端   | Vant4           | Vue3 + Vite            |
| 数据库   | MySQL           | 8.0+                   |
| 缓存     | Redis           | 7.0+                   |
| 部署     | Docker Compose  | 单机部署               |

## 第一阶段：环境搭建与框架部署（第1-3天）

### Day 1：基础环境准备

#### 1.1 开发工具安装

```Bash
# 必需工具
- JDK 17+（Spring Boot 3.x要求）
- Node.js 22（Vue3要求）
- MySQL 8.0
- Redis 7.0
- Maven 3.8+
- Git
- IntelliJ IDEA（推荐）/ VS Code
- Navicat（数据库工具）
```

#### 1.2 下载并运行RuoYi-Vue3

```Bash
# 克隆若依模板
git clone https://gitee.com/y_project/RuoYi-Vue.git ruoyi-hospital
cd ruoyi-hospital

# 切换到SpringBoot3分支（若主分支是SpringBoot2）
git checkout springboot3
```

#### 1.3 数据库初始化

```SQL
-- 创建数据库
CREATE DATABASE ruoyi_hospital DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 执行RuoYi初始化脚本
-- 路径：ruoyi-hospital/sql/ry_20230706.sql（ quartz.sql可选）
```

#### 1.4 配置文件修改

```YAML
# ruoyi-admin/src/main/resources/application-druid.yml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    druid:
      master:
        url: jdbc:mysql://localhost:3306/ruoyi_hospital?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8
        username: root
        password: your_password

# ruoyi-admin/src/main/resources/application-redis.yml
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password: 
      database: 0
```

#### 1.5 启动验证

```Bash
# 后端启动
cd ruoyi-hospital/ruoyi-admin
mvn spring-boot:run

# 前端启动
cd ruoyi-hospital-ui
npm install
npm run dev

# 访问 http://localhost:80
# 默认账号：admin / admin123
```

**Day 1 产出**：RuoYi基础系统跑通，登录成功

### Day 2：项目结构改造

#### 2.1 创建医疗业务模块

```Bash
# 在ruoyi-hospital目录下创建新模块
ruoyi-hospital/
├── ruoyi-admin/          # 管理端（保持原样）
├── ruoyi-common/         # 通用工具（保持原样）
├── ruoyi-framework/      # 框架核心（保持原样）
├── ruoyi-system/         # 系统模块（保持原样）
├── ruoyi-quartz/         # 定时任务（可选）
└── ruoyi-medical/        # 【新增】医疗业务模块
    ├── pom.xml
    └── src/
        ├── main/
        │   ├── java/com/ruoyi/medical/
        │   │   ├── controller/     # 控制器
        │   │   ├── domain/         # 实体类
        │   │   ├── mapper/         # 数据访问层
        │   │   ├── service/        # 业务层
        │   │   └── RuoYiMedicalApplication.java
        │   └── resources/
        │       └── mapper/medical/ # XML映射文件
        └── test/
```

#### 2.2 模块pom.xml配置

```XML
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>ruoyi</artifactId>
        <groupId>com.ruoyi</groupId>
        <version>3.8.5</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    
    <artifactId>ruoyi-medical</artifactId>
    
    <description>
        医疗业务模块：科室、医生、号源、预约管理
    </description>
    
    <dependencies>
        <!-- 通用工具-->
        <dependency>
            <groupId>com.ruoyi</groupId>
            <artifactId>ruoyi-common</artifactId>
        </dependency>
    </dependencies>
</project>
```

#### 2.3 父工程引入新模块

```XML
<!-- ruoyi-hospital/pom.xml -->
<modules>
    <module>ruoyi-admin</module>
    <module>ruoyi-framework</module>
    <module>ruoyi-system</module>
    <module>ruoyi-common</module>
    <module>ruoyi-quartz</module>
    <module>ruoyi-medical</module>  <!-- 添加这一行 -->
</modules>
```

#### 2.4 管理端添加医疗菜单

```SQL
-- 插入医疗业务菜单（在RuoYi管理后台执行，或插入SQL）
INSERT INTO sys_menu (menu_name, parent_id, order_num, path, component, is_frame, is_cache, menu_type, visible, status, perms, icon, create_by, create_time, update_by, update_time, remark)
VALUES ('医疗管理', 0, 5, 'medical', NULL, 0, 0, 'M', '0', '0', NULL, 'el-icon-first-aid-kit', 'admin', NOW(), 'admin', NOW(), '医疗业务管理根菜单');

-- 获取刚插入的菜单ID（假设为100）
SET @parent_id = LAST_INSERT_ID();

INSERT INTO sys_menu (menu_name, parent_id, order_num, path, component, is_frame, is_cache, menu_type, visible, status, perms, icon, create_by, create_time, update_by, update_time, remark)
VALUES 
('科室管理', @parent_id, 1, 'department', 'medical/department/index', 0, 0, 'C', '0', '0', 'medical:department:list', 'el-icon-office-building', 'admin', NOW(), 'admin', NOW(), '医院科室管理'),
('医生管理', @parent_id, 2, 'doctor', 'medical/doctor/index', 0, 0, 'C', '0', '0', 'medical:doctor:list', 'el-icon-user-doctor', 'admin', NOW(), 'admin', NOW(), '医生信息管理'),
('号源管理', @parent_id, 3, 'schedule', 'medical/schedule/index', 0, 0, 'C', '0', '0', 'medical:schedule:list', 'el-icon-calendar', 'admin', NOW(), 'admin', NOW(), '医生排班与号源'),
('预约管理', @parent_id, 4, 'appointment', 'medical/appointment/index', 0, 0, 'C', '0', '0', 'medical:appointment:list', 'el-icon-tickets', 'admin', NOW(), 'admin', NOW(), '患者预约订单');
```

**Day 2 产出**：新模块创建完成，管理端菜单可见

### Day 3：核心数据库设计

#### 3.1 科室表（medical_department）

```SQL
CREATE TABLE medical_department (
    dept_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '科室ID',
    dept_name VARCHAR(50) NOT NULL COMMENT '科室名称',
    dept_code VARCHAR(20) NOT NULL COMMENT '科室编码',
    parent_id BIGINT DEFAULT 0 COMMENT '父科室ID（0为顶级）',
    dept_type TINYINT DEFAULT 1 COMMENT '科室类型：1门诊 2急诊 3住院 4医技',
    location VARCHAR(100) COMMENT '科室位置（如：门诊楼3层）',
    phone VARCHAR(20) COMMENT '科室电话',
    intro TEXT COMMENT '科室简介',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 0 COMMENT '状态：0正常 1停用',
    create_by VARCHAR(64) DEFAULT '' COMMENT '创建者',
    create_time DATETIME DEFAULT NULL COMMENT '创建时间',
    update_by VARCHAR(64) DEFAULT '' COMMENT '更新者',
    update_time DATETIME DEFAULT NULL COMMENT '更新时间',
    remark VARCHAR(500) DEFAULT NULL COMMENT '备注',
    PRIMARY KEY (dept_id),
    UNIQUE KEY uk_dept_code (dept_code),
    KEY idx_parent_id (parent_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='科室信息表';
```

#### 3.2 医生表（medical_doctor）

```SQL
CREATE TABLE medical_doctor (
    doctor_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '医生ID',
    user_id BIGINT COMMENT '关联系统用户ID（RuoYi sys_user）',
    doctor_name VARCHAR(50) NOT NULL COMMENT '医生姓名',
    doctor_code VARCHAR(20) NOT NULL COMMENT '医生工号',
    dept_id BIGINT NOT NULL COMMENT '所属科室ID',
    title VARCHAR(20) COMMENT '职称：主任医师/副主任医师/主治医师/医师',
    specialty VARCHAR(500) COMMENT '擅长领域',
    intro TEXT COMMENT '医生简介',
    avatar VARCHAR(200) COMMENT '头像URL',
    fee DECIMAL(10,2) DEFAULT 0.00 COMMENT '挂号费',
    max_patients INT DEFAULT 20 COMMENT '半日最大接诊数',
    work_status TINYINT DEFAULT 0 COMMENT '工作状态：0在职 1休假 2离职',
    status TINYINT DEFAULT 0 COMMENT '预约状态：0可约 1暂停',
    create_by VARCHAR(64) DEFAULT '' COMMENT '创建者',
    create_time DATETIME DEFAULT NULL COMMENT '创建时间',
    update_by VARCHAR(64) DEFAULT '' COMMENT '更新者',
    update_time DATETIME DEFAULT NULL COMMENT '更新时间',
    remark VARCHAR(500) DEFAULT NULL COMMENT '备注',
    PRIMARY KEY (doctor_id),
    UNIQUE KEY uk_doctor_code (doctor_code),
    KEY idx_dept_id (dept_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='医生信息表';
```

#### 3.3 排班/号源表（medical_schedule）

```SQL
CREATE TABLE medical_schedule (
    schedule_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '排班ID',
    doctor_id BIGINT NOT NULL COMMENT '医生ID',
    work_date DATE NOT NULL COMMENT '出诊日期',
    period TINYINT NOT NULL COMMENT '时段：1上午 2下午 3晚间',
    start_time TIME COMMENT '开始时间',
    end_time TIME COMMENT '结束时间',
    total_slots INT NOT NULL DEFAULT 0 COMMENT '总号源数',
    booked_slots INT DEFAULT 0 COMMENT '已预约数',
    slot_minutes INT DEFAULT 30 COMMENT '每个号源时长（分钟）',
    status TINYINT DEFAULT 0 COMMENT '状态：0正常 1停诊 2已满',
    create_by VARCHAR(64) DEFAULT '' COMMENT '创建者',
    create_time DATETIME DEFAULT NULL COMMENT '创建时间',
    update_by VARCHAR(64) DEFAULT '' COMMENT '更新者',
    update_time DATETIME DEFAULT NULL COMMENT '更新时间',
    remark VARCHAR(500) DEFAULT NULL COMMENT '备注',
    PRIMARY KEY (schedule_id),
    UNIQUE KEY uk_doctor_date_period (doctor_id, work_date, period),
    KEY idx_work_date (work_date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='医生排班号源表';
```

#### 3.4 预约单表（medical_appointment）

```SQL
CREATE TABLE medical_appointment (
    appointment_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '预约ID',
    appointment_no VARCHAR(32) NOT NULL COMMENT '预约单号（业务唯一）',
    patient_id BIGINT NOT NULL COMMENT '患者ID（关联sys_user）',
    visitor_id BIGINT COMMENT '就诊人ID（0表示本人）',
    doctor_id BIGINT NOT NULL COMMENT '医生ID',
    schedule_id BIGINT NOT NULL COMMENT '排班ID',
    appointment_date DATE NOT NULL COMMENT '预约就诊日期',
    period TINYINT NOT NULL COMMENT '时段',
    time_slot VARCHAR(20) COMMENT '具体时间段（如08:00-08:30）',
    status TINYINT DEFAULT 0 COMMENT '状态：0待支付 1待就诊 2就诊中 3已完成 4已取消 5失约',
    fee DECIMAL(10,2) DEFAULT 0.00 COMMENT '挂号费',
    pay_status TINYINT DEFAULT 0 COMMENT '支付状态：0未支付 1已支付 2已退款',
    pay_time DATETIME COMMENT '支付时间',
    pay_way VARCHAR(20) COMMENT '支付方式：wechat/alipay',
    checkin_time DATETIME COMMENT '签到时间',
    finish_time DATETIME COMMENT '就诊完成时间',
    cancel_time DATETIME COMMENT '取消时间',
    cancel_reason VARCHAR(200) COMMENT '取消原因',
    medical_record_id BIGINT COMMENT '关联病历ID',
    create_by VARCHAR(64) DEFAULT '' COMMENT '创建者',
    create_time DATETIME DEFAULT NULL COMMENT '创建时间',
    update_by VARCHAR(64) DEFAULT '' COMMENT '更新者',
    update_time DATETIME DEFAULT NULL COMMENT '更新时间',
    remark VARCHAR(500) DEFAULT NULL COMMENT '备注',
    PRIMARY KEY (appointment_id),
    UNIQUE KEY uk_appointment_no (appointment_no),
    KEY idx_patient_id (patient_id),
    KEY idx_doctor_date (doctor_id, appointment_date),
    KEY idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预约订单表';
```

#### 3.5 就诊人表（medical_patient_visitor）

```SQL
CREATE TABLE medical_patient_visitor (
    visitor_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '就诊人ID',
    patient_id BIGINT NOT NULL COMMENT '主账户患者ID',
    name VARCHAR(50) NOT NULL COMMENT '姓名',
    id_card VARCHAR(18) NOT NULL COMMENT '身份证号（加密）',
    phone VARCHAR(11) COMMENT '手机号',
    relation VARCHAR(10) COMMENT '与主账户关系：本人/配偶/子女/父母/其他',
    gender TINYINT COMMENT '性别：0男 1女',
    birth_date DATE COMMENT '出生日期',
    medical_card_no VARCHAR(30) COMMENT '医保卡号',
    allergy_history TEXT COMMENT '过敏史',
    past_history TEXT COMMENT '既往病史',
    is_default TINYINT DEFAULT 0 COMMENT '是否默认就诊人：0否 1是',
    status TINYINT DEFAULT 0 COMMENT '状态：0正常 1删除',
    create_time DATETIME DEFAULT NULL COMMENT '创建时间',
    update_time DATETIME DEFAULT NULL COMMENT '更新时间',
    PRIMARY KEY (visitor_id),
    KEY idx_patient_id (patient_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='就诊人档案表';
```

**Day 3 产出**：5张核心表创建完成，插入测试数据

## 第二阶段：核心业务开发（第4-15天）

### Week 2：基础CRUD与科室医生管理（第4-7天）

#### Day 4：使用RuoYi代码生成器

```Bash
# 1. 在RuoYi管理后台 -> 系统工具 -> 代码生成
# 2. 导入刚才创建的5张表
# 3. 配置生成信息：
#    - 实体类名：Department / Doctor / Schedule / Appointment / PatientVisitor
#    - 作者：你的名字
#    - 生成包路径：com.ruoyi.medical
#    - 生成模块名：medical
# 4. 预览代码 -> 生成代码 -> 下载zip
# 5. 解压后按目录复制到ruoyi-medical模块对应位置
# 6. 执行生成的menu.sql插入菜单
# 7. 重启后端，刷新前端，基础CRUD页面已可用
```

#### Day 5-6：科室管理定制化

```Java
// 1. 在DepartmentController中添加树形查询
@GetMapping("/tree")
public AjaxResult tree() {
    List<Department> list = departmentService.selectDepartmentList(new Department());
    return AjaxResult.success(buildTree(list));
}

// 2. 前端改造：科室选择组件（下拉树形选择）
// 路径：ruoyi-hospital-ui/src/views/medical/department/index.vue
// 使用el-tree-select组件
```

#### Day 7：医生管理与科室关联

```Java
// DoctorService.java 关键方法
@Override
public List<Doctor> selectDoctorList(Doctor doctor) {
    // 关联查询科室名称
    return doctorMapper.selectDoctorList(doctor);
}

// 前端：医生列表增加科室筛选、职称筛选
// 医生详情页面：展示头像、擅长领域、挂号费
```

**Week 2 产出**：管理端可维护科室、医生信息

### Week 3：号源管理（排班系统）（第8-11天）

#### Day 8-9：排班日历功能

```Java
// ScheduleController.java
/**
 * 获取医生某月排班（日历视图）
 */
@GetMapping("/calendar")
public AjaxResult getCalendar(@RequestParam Long doctorId, 
                              @RequestParam String month) {
    // 返回该月每天的排班状态
    List<ScheduleCalendarVO> list = scheduleService.getCalendar(doctorId, month);
    return AjaxResult.success(list);
}

/**
 * 批量生成排班（按模板）
 */
@PostMapping("/batch")
public AjaxResult batchGenerate(@RequestBody BatchScheduleDTO dto) {
    // 根据规则批量生成未来30天排班
    scheduleService.batchGenerate(dto);
    return AjaxResult.success();
}
<!-- 前端：排班日历组件（使用vue-calendar-heatmap或自研） -->
<template>
  <div class="schedule-calendar">
    <el-calendar>
      <template #dateCell="{ data }">
        <div :class="getScheduleClass(data.date)">
          <span>{{ data.day.split('-').slice(1).join('-') }}</span>
          <div v-if="hasSchedule(data.date)" class="schedule-info">
            <el-tag size="small" :type="getStatusType(data.date)">
              {{ getStatusText(data.date) }}
            </el-tag>
          </div>
        </div>
      </template>
    </el-calendar>
  </div>
</template>
```

#### Day 10-11：号源库存管理

```Java
// 号源调整：临时加号、停诊、号源释放
@Service
public class ScheduleServiceImpl implements IScheduleService {
    
    @Override
    @Transactional
    public void addExtraSlots(Long scheduleId, int count) {
        Schedule schedule = scheduleMapper.selectById(scheduleId);
        // 校验：不能超过医生最大负荷
        int maxSlots = calculateMaxSlots(schedule.getDoctorId(), schedule.getPeriod());
        if (schedule.getTotalSlots() + count > maxSlots) {
            throw new ServiceException("超出医生最大接诊能力");
        }
        scheduleMapper.addSlots(scheduleId, count);
    }
    
    @Override
    @Transactional
    public void stopSchedule(Long scheduleId, String reason) {
        // 停诊：更新状态，通知已预约患者
        Schedule schedule = new Schedule();
        schedule.setScheduleId(scheduleId);
        schedule.setStatus(1); // 停诊
        schedule.setRemark(reason);
        scheduleMapper.update(schedule);
        
        // 异步通知患者（后续实现）
        notifyPatients(scheduleId, reason);
    }
}
```

**Week 3 产出**：管理端可维护排班，支持日历视图

### Week 4：预约核心（并发控制）（第12-15天）

#### Day 12-13：预约下单接口（重点：防超卖）

```Java
// AppointmentService.java
@Service
@Slf4j
public class AppointmentServiceImpl implements IAppointmentService {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private ScheduleMapper scheduleMapper;
    
    @Autowired
    private AppointmentMapper appointmentMapper;
    
    /**
     * 预约下单（分布式锁 + Redis预减 + DB唯一索引防重）
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Appointment createAppointment(AppointmentDTO dto) {
        Long scheduleId = dto.getScheduleId();
        String lockKey = "lock:schedule:" + scheduleId;
        String lockValue = UUID.randomUUID().toString();
        
        // 1. 获取分布式锁（防止并发超卖）
        Boolean locked = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, 10, TimeUnit.SECONDS);
        if (!locked) {
            throw new ServiceException("系统繁忙，请稍后重试");
        }
        
        try {
            // 2. Redis预减库存（保证原子性）
            String stockKey = "stock:schedule:" + scheduleId;
            Long stock = redisTemplate.opsForValue().decrement(stockKey);
            if (stock == null || stock < 0) {
                // 库存不足，回滚Redis
                redisTemplate.opsForValue().increment(stockKey);
                throw new ServiceException("号源已满");
            }
            
            // 3. 数据库扣减（乐观锁）
            int affected = scheduleMapper.decreaseSlot(scheduleId);
            if (affected == 0) {
                // 扣减失败，回滚Redis
                redisTemplate.opsForValue().increment(stockKey);
                throw new ServiceException("号源已被预约");
            }
            
            // 4. 创建预约单
            Appointment appointment = new Appointment();
            appointment.setAppointmentNo(generateOrderNo());
            appointment.setPatientId(dto.getPatientId());
            appointment.setVisitorId(dto.getVisitorId());
            appointment.setDoctorId(dto.getDoctorId());
            appointment.setScheduleId(scheduleId);
            appointment.setAppointmentDate(dto.getAppointmentDate());
            appointment.setPeriod(dto.getPeriod());
            appointment.setTimeSlot(dto.getTimeSlot());
            appointment.setFee(dto.getFee());
            appointment.setStatus(0); // 待支付
            appointment.setPayStatus(0);
            
            // 5. 唯一索引防重（patient_id + schedule_id + visitor_id）
            try {
                appointmentMapper.insert(appointment);
            } catch (DuplicateKeyException e) {
                // 重复预约，回滚
                redisTemplate.opsForValue().increment(stockKey);
                scheduleMapper.increaseSlot(scheduleId);
                throw new ServiceException("您已预约该时段，请勿重复预约");
            }
            
            // 6. 设置支付超时（5分钟）
            String payTimeoutKey = "pay:timeout:" + appointment.getAppointmentId();
            redisTemplate.opsForValue().set(payTimeoutKey, "1", 5, TimeUnit.MINUTES);
            
            return appointment;
            
        } finally {
            // 释放锁（Lua脚本保证原子性）
            releaseLock(lockKey, lockValue);
        }
    }
    
    private String generateOrderNo() {
        // 生成规则：AP + yyyyMMdd + 6位随机数
        return "AP" + DateUtils.dateTimeNow("yyyyMMdd") + 
               RandomUtil.randomNumbers(6);
    }
}
-- 数据库唯一索引（最后一道防线）
ALTER TABLE medical_appointment 
ADD UNIQUE KEY uk_patient_schedule (patient_id, schedule_id, visitor_id);
```

#### Day 14：支付回调与状态流转

```Java
/**
 * 支付回调（模拟，实际对接微信支付）
 */
@PostMapping("/pay/callback")
public String payCallback(@RequestBody PayCallbackDTO dto) {
    // 1. 验签
    // 2. 更新预约单状态
    appointmentService.paySuccess(dto.getAppointmentNo(), dto.getPayWay());
    return "success";
}

@Transactional
public void paySuccess(String appointmentNo, String payWay) {
    Appointment appointment = appointmentMapper.selectByNo(appointmentNo);
    if (appointment == null || appointment.getPayStatus() != 0) {
        return; // 已处理或不存在
    }
    
    // 更新状态
    Appointment update = new Appointment();
    update.setAppointmentId(appointment.getAppointmentId());
    update.setStatus(1); // 待就诊
    update.setPayStatus(1); // 已支付
    update.setPayWay(payWay);
    update.setPayTime(new Date());
    appointmentMapper.update(update);
    
    // 删除支付超时Key
    redisTemplate.delete("pay:timeout:" + appointment.getAppointmentId());
    
    // 发送预约成功通知（后续接入消息服务）
}

/**
 * 定时任务：处理支付超时订单
 */
@Scheduled(fixedRate = 60000) // 每分钟执行
public void handlePayTimeout() {
    // 查询超时未支付订单（也可通过Redis Key过期监听）
    List<Appointment> timeoutList = appointmentMapper.selectTimeoutList(5);
    for (Appointment appointment : timeoutList) {
        cancelAppointment(appointment.getAppointmentId(), "支付超时自动取消");
    }
}
```

#### Day 15：取消预约与退款

```Java
/**
 * 取消预约（带规则校验）
 */
@Transactional
public void cancelAppointment(Long appointmentId, String reason) {
    Appointment appointment = appointmentMapper.selectById(appointmentId);
    if (appointment == null) {
        throw new ServiceException("预约单不存在");
    }
    
    // 1. 状态校验
    if (appointment.getStatus() != 0 && appointment.getStatus() != 1) {
        throw new ServiceException("当前状态不可取消");
    }
    
    // 2. 时间规则校验
    LocalDateTime appointmentTime = LocalDateTime.of(
        appointment.getAppointmentDate(), 
        getPeriodStartTime(appointment.getPeriod())
    );
    long hoursUntil = ChronoUnit.HOURS.between(LocalDateTime.now(), appointmentTime);
    
    if (hoursUntil < 2) {
        throw new ServiceException("就诊前2小时内不可取消");
    }
    
    // 3. 计算退款金额（根据取消时间）
    BigDecimal refundAmount = calculateRefund(appointment, hoursUntil);
    
    // 4. 更新状态
    Appointment update = new Appointment();
    update.setAppointmentId(appointmentId);
    update.setStatus(4); // 已取消
    update.setCancelTime(new Date());
    update.setCancelReason(reason);
    appointmentMapper.update(update);
    
    // 5. 恢复号源
    scheduleMapper.increaseSlot(appointment.getScheduleId());
    redisTemplate.opsForValue().increment("stock:schedule:" + appointment.getScheduleId());
    
    // 6. 发起退款（若已支付）
    if (appointment.getPayStatus() == 1) {
        refundService.refund(appointment.getAppointmentNo(), refundAmount);
    }
}
```

**Week 4 产出**：核心预约流程跑通，并发安全

## 第三阶段：多端前端开发（第16-23天）

### Week 5：管理端完善（第16-18天）

基于RuoYi-Vue3自带前端，完善医疗模块页面：

```Bash
# 目录结构
ruoyi-hospital-ui/src/views/medical/
├── department/
│   └── index.vue          # 科室管理（树形表格）
├── doctor/
│   └── index.vue          # 医生管理（关联科室）
├── schedule/
│   ├── index.vue          # 排班列表
│   └── calendar.vue       # 排班日历视图
├── appointment/
│   └── index.vue          # 预约订单管理
└── dashboard/
    └── index.vue          # 数据大屏（集成DataV）
```

### Week 6：医生端开发（第19-21天）

使用**Pure Admin**搭建医生工作站：

```Bash
# 1. 克隆Pure Admin
git clone https://github.com/pure-admin/vue-pure-admin.git doctor-workstation
cd doctor-workstation

# 2. 安装依赖
pnpm install

# 3. 配置后端API地址
# .env.development
VITE_APP_BASE_API = 'http://localhost:8080'

# 4. 创建医生端页面
src/views/
├── workbench/             # 工作台（今日概览）
│   └── index.vue
├── queue/                 # 候诊队列（WebSocket实时）
│   └── index.vue
├── consult/               # 接诊/病历
│   └── index.vue
└── schedule/              # 我的排班
    └── index.vue
```

**候诊队列实时推送（WebSocket）**：

```Java
// 后端：WebSocket配置（使用Spring WebSocket + STOMP）
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws/doctor")
                .setAllowedOrigins("*")
                .withSockJS();
    }
}

// 叫号时推送消息
@Autowired
private SimpMessagingTemplate messagingTemplate;

public void callNextPatient(Long doctorId, PatientQueueVO patient) {
    messagingTemplate.convertAndSend(
        "/topic/queue/" + doctorId, 
        patient
    );
}
<!-- 前端：医生端候诊队列 -->
<template>
  <div class="queue-container">
    <div class="current-patient" v-if="current">
      <h2>当前就诊</h2>
      <div class="patient-card">
        <span class="name">{{ current.name }}</span>
        <span class="seq">序号：{{ current.queueNo }}</span>
      </div>
      <el-button type="primary" size="large" @click="finishCurrent">
        完成就诊
      </el-button>
    </div>
    
    <div class="waiting-list">
      <h3>候诊队列（{{ waitingList.length }}人）</h3>
      <el-table :data="waitingList">
        <el-table-column prop="queueNo" label="序号" width="80" />
        <el-table-column prop="name" label="患者" />
        <el-table-column prop="appointmentTime" label="预约时间" />
        <el-button type="text" @click="callPatient(row)">叫号</el-button>
      </el-table>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import SockJS from 'sockjs-client'
import Stomp from 'stompjs'

const doctorId = 1 // 当前登录医生ID
const stompClient = ref(null)

onMounted(() => {
  connectWebSocket()
})

const connectWebSocket = () => {
  const socket = new SockJS('http://localhost:8080/ws/doctor')
  stompClient.value = Stomp.over(socket)
  stompClient.value.connect({}, () => {
    // 订阅个人队列
    stompClient.value.subscribe(`/topic/queue/${doctorId}`, (msg) => {
      const patient = JSON.parse(msg.body)
      handleNewPatient(patient)
    })
  })
}
</script>
```

### Week 7：患者端H5（第22-23天）

使用**Vant4**开发患者端：

```Bash
# 1. 创建Vant项目
npm create vant-app@latest patient-h5
# 选择：Vue3 + Vite + TypeScript

cd patient-h5
npm install

# 2. 安装额外依赖
npm install axios vue-router pinia dayjs

# 3. 配置代理（vite.config.ts）
server: {
  proxy: {
    '/api': {
      target: 'http://localhost:8080',
      changeOrigin: true
    }
  }
}
```

**患者端页面结构**：

```Bash
src/
├── views/
│   ├── home/              # 首页（科室入口、搜索）
│   │   └── index.vue
│   ├── department/        # 科室列表
│   │   └── index.vue
│   ├── doctor/            # 医生列表/详情
│   │   ├── list.vue
│   │   └── detail.vue
│   ├── schedule/          # 排班选择
│   │   └── index.vue
│   ├── appointment/       # 确认预约/支付
│   │   ├── confirm.vue
│   │   └── success.vue
│   ├── order/             # 我的预约
│   │   └── list.vue
│   └── profile/           # 个人中心
│       └── index.vue
├── api/                   # API接口封装
└── stores/                # Pinia状态管理
```

**核心页面示例：医生详情与预约**：

```Plain
<!-- src/views/doctor/detail.vue -->
<template>
  <div class="doctor-detail">
    <van-nav-bar title="医生详情" left-arrow @click-left="goBack" />
    
    <div class="doctor-header">
      <van-image round width="80" height="80" :src="doctor.avatar" />
      <div class="info">
        <h2>{{ doctor.name }} <van-tag>{{ doctor.title }}</van-tag></h2>
        <p>{{ doctor.deptName }}</p>
        <p class="specialty">{{ doctor.specialty }}</p>
      </div>
    </div>
    
    <van-tabs v-model:active="activeDate">
      <van-tab v-for="date in dateList" :title="date.label" :key="date.value">
        <div class="period-list">
          <div v-for="period in periods" :key="period.value" class="period-item">
            <h4>{{ period.label }}</h4>
            <div class="slots">
              <van-button 
                v-for="slot in getSlots(date.value, period.value)" 
                :key="slot.time"
                :type="slot.status === 0 ? 'primary' : 'default'"
                :disabled="slot.status !== 0"
                size="small"
                @click="selectSlot(date.value, period.value, slot)"
              >
                {{ slot.time }} ({{ slot.stock }}号)
              </van-button>
            </div>
          </div>
        </div>
      </van-tab>
    </van-tabs>
    
    <!-- 预约确认弹窗 -->
    <van-action-sheet v-model:show="showConfirm" title="确认预约">
      <div class="confirm-content">
        <p>就诊医生：{{ doctor.name }}</p>
        <p>就诊时间：{{ selected.date }} {{ selected.period }} {{ selected.time }}</p>
        <p>就诊人：
          <van-radio-group v-model="selected.visitorId">
            <van-radio v-for="v in visitors" :name="v.visitorId">
              {{ v.name }} ({{ v.relation }})
            </van-radio>
          </van-radio-group>
        </p>
        <p>挂号费：¥{{ doctor.fee }}</p>
        <van-button type="primary" block @click="submitAppointment">
          确认预约
        </van-button>
      </div>
    </van-action-sheet>
  </div>
</template>
```

## 第四阶段：测试与部署（第24-30天）

### Week 8：测试优化（第24-26天）

| 任务     | 内容                     | 工具                   |
| -------- | ------------------------ | ---------------------- |
| 单元测试 | Service层核心方法        | JUnit + Mockito        |
| 接口测试 | Postman集合，覆盖所有API | Postman                |
| 并发测试 | JMeter模拟100并发预约    | JMeter                 |
| 前端测试 | 多端兼容性测试           | Chrome DevTools + 真机 |

**JMeter并发测试配置**：

```Bash
# 测试计划：号源抢购
线程数：100
Ramp-Up：5秒
循环次数：1
HTTP请求：POST /medical/appointment/create
参数：scheduleId=1（同一号源）
断言：响应不包含"号源已满"的比例 < 5%（允许少量冲突）
```

### Week 9：部署上线（第27-30天）

#### Docker Compose配置

```YAML
# docker-compose.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    container_name: hospital-mysql
    environment:
      MYSQL_ROOT_PASSWORD: your_password
      MYSQL_DATABASE: ruoyi_hospital
    volumes:
      - ./data/mysql:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "3306:3306"
      
  redis:
    image: redis:7-alpine
    container_name: hospital-redis
    volumes:
      - ./data/redis:/data
    ports:
      - "6379:6379"
      
  backend:
    build: ./ruoyi-hospital/ruoyi-admin
    container_name: hospital-backend
    depends_on:
      - mysql
      - redis
    environment:
      SPRING_PROFILES_ACTIVE: prod
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/ruoyi_hospital
      SPRING_REDIS_HOST: redis
    ports:
      - "8080:8080"
      
  nginx:
    image: nginx:alpine
    container_name: hospital-nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./dist:/usr/share/nginx/html  # 前端打包文件
    ports:
      - "80:80"
    depends_on:
      - backend
```

#### 部署步骤

```Bash
# 1. 服务器准备（推荐阿里云ECS 2核4G）
# 2. 安装Docker和Docker Compose
curl -fsSL https://get.docker.com | bash

# 3. 上传项目代码
scp -r ruoyi-hospital root@your-server:/opt/
scp -r ruoyi-hospital-ui/dist root@your-server:/opt/
scp docker-compose.yml root@your-server:/opt/

# 4. 启动服务
cd /opt
docker-compose up -d

# 5. 查看日志
docker-compose logs -f backend
```

## 关键里程碑检查点

| 时间   | 里程碑     | 验收标准                                   |
| ------ | ---------- | ------------------------------------------ |
| Day 3  | 环境就绪   | RuoYi跑通，数据库创建完成                  |
| Day 7  | 基础数据   | 管理端可维护科室、医生                     |
| Day 11 | 号源系统   | 排班日历正常，号源可管理                   |
| Day 15 | 核心交易   | 预约下单、支付、取消流程跑通，并发测试通过 |
| Day 21 | 医生端可用 | 医生可登录、看队列、写病历                 |
| Day 23 | 患者端可用 | H5可完成完整预约流程                       |
| Day 26 | 测试完成   | 无P0级Bug，性能达标                        |
| Day 30 | 正式上线   | 生产环境部署，域名可访问                   |
